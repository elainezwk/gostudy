## 嵌套
// 当数据类型比较复杂时，可以设置为多个结构体，之后可以再某个结构体的一个成员变量中去声明另外一种类型的变量
// 多个结构体有相互依赖关系时，可以使用结构体嵌套。
// 如果嵌套时，成员变量有名称重复时，就不能直接赋值，要用全路径赋值 例如 info1.Phone.Name="小米"

## 接口 interface
Go语言的接口是一种类型，定义了一组方法的集合，但是接口又不需要去实现它们，这些方法可以被不同的类型实现，进而就是这个类型实现了这个接口。
在Go语言中，接口是一个重要的概念，接口被广泛应用于许多标准库和框架中。通过接口，可以使不同的类型之间实现相同的行为，从而达到代码复用和扩展的目的，而且可以实现不同类型之间的无缝切换。
空接口，空接口不会定义任何的方法，无论什么类型都实现了这个接口。空接口是可以接收任何类型的参数。
接口类型断言和类型判断：
类型断言：大致知道了接口可能是某种类型，然后使用t, ok := i.(可能的类型)
类型查询：switch t := i.(type) 

## 并发和并行
why：提高资源利用率、加快数据处理速度、提高系统可伸缩性、改善用户体验
并发：同时处理多个任务的能力（一个处理器）
并行：同时执行多个任务的能力（多个处理器）

## 线程、协程
线程（Thread）是计算机操作系统中程序运行时最小的执行单元，是CPU调度的基本单元。一个线程可以理解为一个任务，都具有一个独立的控制流。在多线程编程中，可以将不同的任务或操作封装在不同的线程中，然后并发地执行这些任务，从而提高程序的性能和响应速度。
协程（Coroutine）是一种轻量级的线程，也被称为用户态线程。与操作系统中的线程不同，协程由程序员自己管理调度。协程可以使用更少的资源，更快的创建和销毁，协程之间可以通过通道（channel）进行通信和同步，避免了传统线程中锁等同步机制的开销和复杂性。
go: goroutine并发处理，go 代码语句  就创建了一个协程
创建一个协程开销2KB，创建一个线程开销8MB。不需要关系协程的底层逻辑、内存管理、垃圾回收，在内部会自动处理。
主程序创建了协程以后，并不会等待所有的写成执行成功，需要主程序等待写成处理完成之后再去退出

## 通道channel
### 使用通道共享数据
go的通道也是一种类型，channel1 := make(chan 类型) 声明一个通道，这种方式生命的通道只有一个位置，只能存放一个数据。
发送数据：channel1 <- "数据1"
取数据： data1 := <- channel1
使用通道来共享数据。并发时建议用通道，避免加解锁的开销。
关闭通道：close(buns)
### 使用缓冲channel防止阻塞
如果通道内没有数据，就会一直在此处阻塞，直到取到数据为止。如果通道内数据放满了，一直没有取也会阻塞。
通道阻塞：通道满了放数据 或 通道无数据取数据 都会发生通道阻塞。
设置n个位置的通道：buns := make(chan string, 5)
### select处理多个通道及通道超时处理
使用select处理多个通道以及通道超时处理。当有多个通道时，只要有一个通道有了数据之后，就选择处理然后退出，此时选择使用select语句。select 包含多个case语句，每个case语句用于接收某一个通道的数据。超时处理：在最后增加一个case，在该case下执行一些内容然后退出。case <-time.After(time.Second * 3): do something 超时时间设置为3秒
当某一个通道有了数据之后，就会执行对应的case语句。多个case语句同时包含了数据，会随机执行某一个。
### 监听通道的退出

## 包 package
内置包、外部包。https://pkg.go.dev/
import m "math"
import _ "包名" 引入包并初始化
import (
    "fmt"
    m "math"
)


## 包及包管理：go mod
### 包
Go语言自定义包是Go语言中模块化编程的重要组成部分，通过将代码封装在包中，可以实现更好的代码复用、可维护性和可扩展性。同时，自定义包也可以方便地分享给其他开发者使用，可以提高部门或团队的开发效率。优点如下：提高代码复用率、实现代码解耦、提高代码可读性、提高代码安全性、提供团队开发效率。
自定义包名称：最好是小写字母，并且最好不要带下划线，见名知义
### 包管理
查看环境，go env
设置开启mod：go env -w GO111MODULE=on
设置代理：go env -w GOPROXY=https://goproxy.cn,direct
GO111MODULE的值：
on：开启go mod, 从go.mod文件中读取依赖关系；
off：关闭go mod, 完全依赖 GOPATHvendor目录；
auto：开启，只有项目目录下有go.mod文件时才会生效。

go mod init {模块名称}: 初始化一个新模块，并在当前目录下创建go mod文件
go mod tidy: 清理未使用的依赖项，并更新go.mod文件
go mod download: 下载当前模块及共依赖项的所有依赖
go mod vendor: 将依赖项复制到vendor目录中，便于离线部署
go list -in all: 列出当前模块及其依赖项的所有模块和版本
go get: 获取指定的包或模块，并将其添加到go.mod文作中
go get -u: 更新指定包版本


## 项目部署
### 如何部署
1. 拿到代码；
2. 编译成一个二进制包；
3. ./二进制包  --> 镜像；go build -o demo main.go
4. 镜像推送到镜像仓库；
5. docker run
6. yaml文件
### docker部署，每次修改需要打包&更新镜像
### k8s部署，自动打包更新镜像
yml文件

